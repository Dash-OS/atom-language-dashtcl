fileTypes: [
  "tcl"
  "tm"
  "tk"
  "dash"
  "dashsh"
]
scopeName: "source.tcl"
firstLineMatch: "^#!/.*\\b(dashsh|tclsh|wish)(8|8\\.\\d+)?\\b"
foldingStartMarker: "(/\\*|{|\\(|\\[)",
foldingEndMarker: "(\\*/|\\}|\\)|\\])",
name: "Tcl"
patterns: [
  { include: "#root" }
]
repository:
  "root":
    patterns: [
      { include: "#invariant" }
      { include: "#brackets" }
      { include: "#proc-call" }
    ]
  "invariant":
    patterns: [
      { include: "#ignore-long-lines" }
      { include: "#no-starting-empty-brackets" }
      { include: "#no-empty-square-brackets" }
    ]
  "no-starting-empty-brackets":
    patterns: [
      {
        match: "(?<=^)\\s*+(\\{\\}|\\[\\])"
        captures:
          1: name: "invalid.illegal.termination.tcl"
      }
    ]
  "no-empty-square-brackets":
    patterns: [
      {
        match: "(\\[\\])"
        captures:
          1: name: "invalid.illegal"
      }
    ]
  "ignore-long-lines":
    comment: "long lines are not parsed for performance"
    patterns: [ { match: "^.{1000,}" } ]
  "brackets": {
    patterns: [
      { include: "#invariant" }
      { include: "#special-brackets" }
      { include: "#empty-brackets" }
      { include: "#square-brackets" }
      { include: "#curly-brackets" }
    ]
  }
  "square-brackets":
    patterns: [
      {
        begin: "\\s*+(\\[)"
        end: "\\s*(\\])"
        beginCaptures:
          1: name: "meta.brace.square.open.tcl"
        endCaptures:
          1: name: "meta.brace.square.close.tcl"
        patterns: [
          { include: "#invariant" }
          { include: "#proc-call" }
        ]
      }
    ]
  "curly-brackets":
    patterns: [
      {
        begin: "\\s*+({)"
        end: "(})"
        name: "meta.curly.enclosed"
        beginCaptures:
          1: name: "meta.brace.curly.open.tcl"
        endCaptures:
          1: name: "meta.brace.curly.close.tcl"
        patterns: [
          { include: "#invariant" }
          { include: "#curly-brackets" }
          { include: "#proc-call" }

        ]
      }
    ]
  "curly-string-brackets":
    patterns: [
      { include: "#empty-brackets" }
      {
        begin: "\\s*+({)"
        end: "\\s*(})"
        name: "meta.curly.enclosed"
        contentName: "string.quote.bracketed.nosubstitution.tcl"
        beginCaptures:
          1: name: "meta.brace.curly.open.tcl"
        endCaptures:
          1: name: "meta.brace.curly.close.tcl"
          2: name: "invalid.illegal.charafterbrace.tcl"
        patterns: [
          { include: "#variable-non-substituting" }
          { include: "#curly-string-brackets" }
          {
            match: "\\s*([^\\s|}|{|\"]*)"
            name: "string.quote"
          }
        ]
      }
    ]
  "empty-brackets":
    patterns: [
      {
        match: "\\s*({})"
        captures:
          1: name: "punctuation.definition.string.brackets.tcl"
      }
    ]
  "special-brackets":
    comment: "Support for special cases that brackets may be used"
    patterns: [
      {
        comment: "Need to handle the case that we have {*}$varname"
        include: "#variable"
      }
      {
        comment: "Need to handle the case we spread a command {*}[list one two]"
        match: "\\s*({(\\*)}?)(?=\\[|{)"
        captures:
          1: name: "entity.function.name.tcl.markup.italic"
          2: name: "support.type"
      }
    ]
  "expression-brackets":
    patterns: [
      {
        comment: "Expressions utilize special syntax highlighting"
        begin: "(\\{)"
        end: "(\\})"
        beginCaptures:
          1: name: "meta.expression.start.tcl"
        endCaptures:
          1: name: "meta.expression.end.tcl"
        patterns: [
          { include: "#empty-brackets" }
          { include: "#expressions" }
        ]
      }
    ]
  "proc-call":
    comment: "handles a proc call"
    patterns: [
      { include: "#invariant" }
      { include: "#variable" }
      { include: "#comment-blocks" }
      { include: "#keywords" }
      { include: "#proc-call-args" }
    ]
  "proc-call-args":
    comment: "Arguments given to a proc that is being called"
    patterns: [
      { include: "#special-brackets" }
      { include: "#brackets" }
      { include: "#line-escape" }
      { include: "#opt" }
      { include: "#quoted-string" }
      { include: "#variable" }
      { include: "#constant-numeric" }
      { include: "#bare-string" }
    ]
  "keywords":
    patterns: [
      { include: "#special-brackets" }
      { include: "#variable" }
      { include: "#tcl-proc" }
      { include: "#tcl-string" }
      { include: "#tcl-switch" }
      { include: "#tcl-info" }
      { include: "#tcl-json" }
      { include: "#tcl-incr" }
      { include: "#tcl-interp" }
      { include: "#tcl-oo" }
      { include: "#tcl-try-catch" }
      { include: "#tcl-setters" }
      { include: "#tcl-expression-keywords" }
      { include: "#tcl-dict" }
      { include: "#tcl-foreach" }
      { include: "#tcl-namespace" }
      { include: "#tcl-oo-keywords" }
      { include: "#constant-numeric" }
      { include: "#tcl-graphql" }
      { include: "#tcl-state" }
      { include: "#tcl-lassign" }
      { include: "#tcl-catch" }
      { include: "#tcl-ns-commands" }
      { include: "#tcl-puts" }
      { include: "#tcl-entity-commands" }
      {
        match: "\\s*+\\b(destroy)\\b"
        name: "keyword.control.special.tcl"
      }
      {
        match: "(?<=^|\\[|{|;)\\s*(::)?\\b(try|apply|fconfigure|chan|open|close|next|package|while|format|lindex|lsort|glob|tuapi|subst|upvar|uplevel|fileutil|continue|cluster|break|default|yield|load|split|switch|yieldto|catch|source|cd|file|wget|join|throw|lrange|lset|lmap|lassign|llength|lwhere|list|return|puts|clock|include|includes|state|variable|after|task|return|json|interp)\\b(::)?"
        name: "keyword.control.tcl"
        captures:
          1: name: "entity.function.name"
          2: name: "keyword.control.tcl"
          3: name: "entity.function.name"
      }
      {
        match: "(?<=\\s)(::)(?!\\s)"
        name: "support.type"
      }
      {
        match: "(?:(?<=^|\\[|{|;)\\s*|(?<=::)(?!\\s))([^\\s|}|\\]|{|\\[|;|\\\\|\"]*)(?=\\s|$|\n|\\]|})"
        captures:
          1:
            patterns: [
              { include: "#namespace-name" }
            ]
      }
    ]
  "expressions":
    patterns: [
      { include: "#variable" }
      { include: "#square-brackets" }
      { include: "#constant-numeric" }
      { include: "#expression-operators" }
      { include: "#expression-functions" }
      {
        comment: "order-of-operations"
        begin: "\\s*+(?<=\\s|{)(\\()"
        end: "\\s*(\\))"
        beginCaptures:
          1: name: "entity.function.name.expression.brace.ooo.open.tcl"
        endCaptures:
          1: name: "entity.function.name.expression.brace.ooo.close.tcl"
        patterns: [
          { include: "#expressions" }
        ]
      }
      { include: "#quoted-string" }
    ]
  "constant-numeric":
    patterns: [
      {
          match: "\\s*((?:#?|\\.)?(?:\\B[-+])?(?:\\b0[bB][0-1]*|\\b0[oO][0-7]*|\\b0[xX][0-9a-fA-F]*|(\\B\\.[0-9]+|\\b[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?))"
          captures:
            1: name: "meta.constant.numeric"
      }
      {
        match: "\\s*+\\b(true|false|bool|entier|integer|float)\\b"
        name: "meta.constant"
      }
    ]

  "expression-operators":
    patterns: [
      {
        comment: "expression word operators"
        match: "\\s*\\b(in|ni|eq|ne)\\b"
        name: "support.type.operator.tcl"
      }
      {
        comment: "expression operators"
        match: "\\s*(=|\\+|-|\\*|/|%)"
        name: "support.type.operator.tcl"
      }
      {
        comment: "expression comparisons"
        match: "(<|>)"
        name: "support.type.expression.operator.tcl"
      }
      {
        comment: "expression bitwise"
        match: "(\\||\\^|&|!|~)"
        name: "support.type.expression.operator.tcl"
      }
      {
        comment: "expression ternary"
        match: "(\\?|\\:)"
        name: "support.type.expression.operator.tcl"
      }
    ]
  "expression-functions":
    patterns: [
      {
        begin: "\\b(abs|acos|asin|atan|atan2|bool|ceil|cos|cosh|double|entier|exp|floor|fmod|hypot|int|isqrt|log|log10|max|min|pow|rand|round|sin|sinh|sqrt|srand|tan|tanh|wide)\\b(\\()"
        end: "(\\))"
        beginCaptures:
          1: name: "entity.function.name.math.function.tcl"
          2: name: "entity.function.name.math.function.brace.open.tcl"
        endCaptures:
          1: name: "entity.function.name.math.function.brace.close.tcl"
        patterns: [
          { include: "#expressions" }
        ]
      }
    ]
  "tcl-proc":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(proc)\\s+([^\\s]*)\\s+"
        end: "(?<=})"
        endCaptures:
          1: name: "invalid.illegal"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.proc.tcl"
          3:
            patterns: [
              { include: "#namespace-name" }
            ]
        patterns: [
          { include: "#proc-arguments" }
          { include: "#brackets" }
        ]
      }
    ]
  "tcl-graphql":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(graphql)(\\s+[^\\s]*)\\s*([^\\s|{|\\[]*)"
        end: "(?<=})"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.graphql.tcl"
          3: name: "entity.function.name.graphql.tcl"
          4: name: "meta.class"
        patterns: [
          { include: "#curly-string-brackets" }
        ]
      }
    ]
  "tcl-switch":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(switch)\\b"
        end: "(?=$|\n|^)"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.switch.tcl"
          3: name: "entity.function.name.state.tcl"
        patterns: [
          { include: "#opt" }
          {
            match: "\\s(--)\\s"
            name: "keyword.control.switch.opts.complete.tcl"
          }
          { include: "#square-brackets" }
          {
            begin: "\\s*+({)"
            end: "\\s*(})"
            beginCaptures:
              1: name: "meta.brace.switch.open.tcl"
            endCaptures:
              1: name: "meta.brace.switch.close.tcl"
            patterns: [
              {
                applyEndPatternLast: 1
                begin: "(?<=\\s)"
                end: "\\s*"
                patterns: [
                  { include: "#empty-brackets" }
                  {
                    match: "\\s+(-)(?=\\s)"
                    name: "support.type"
                  }
                  { include: "#brackets" }
                  { include: "#glob-match" }
                  { include: "#bare-string" }
                ]
              }
            ]
          }
          { include: "#proc-call-args" }
        ]
      }
    ]
  "tcl-state":
    patterns: [
      {
        # applyEndPatternLast: 1
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(state)\\b(\\s+[^\\s|$|\n]*)"
        end: "\\s*(?=$|}|\\]|;)"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.proc.tcl"
          3: name: "entity.function.name.state.tcl"
        patterns: [
          { include: "#tcl-state-configure" }
          { include: "#tcl-state-register" }
          { include: "#tcl-state-subscribe" }
          { include: "#tcl-state-setter-getter" }
        ]
      }
    ]
  "tcl-puts":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*\\b(puts)\\b(?:\\s+([^\\s|\\$]*)\\s+(?!$|^))?"
        end: "\\s*(?=$|}|\\]|;)"
        beginCaptures:
          1: name: "keyword.control.puts.tcl"
          2: name: "support.type.punctuation.italic"
        patterns: [
          { include: "#variable" }
          { include: "#square-brackets"}
          { include: "#curly-string-brackets" }
          { include: "#quoted-string" }
          { include: "#bare-string" }
        ]
      }
    ]
  "tcl-state-configure":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=configure)\\s+([^\\s|$|}|\\]|\\[|{|;|\\\\]*)"
        end: "(?=$|\n)"
        beginCaptures:
          1: name: "meta.class"
          2:
            patterns: [
              { include: "#tcl-class-name" }
            ]
        patterns: [
          { include: "#line-escape" }
          { include: "#proc-call-args" }
        ]
      }
    ]
  "tcl-state-register":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=register)\\s+([^\\s]*)"
        end: "\\s*"
        captures:
          1: name: "meta.class.state.name.tcl"
        patterns: [
          { include: "#line-escape" }
          {
            begin: "\\s*+({)"
            end: "\\s*(})"
            patterns: [
              {
                match: "(?<=^|\\s)\\s*(title)\\b(\\s+[^$|\n|;]*)"
                captures:
                  1: name: "keyword.state.register.tcl"
                  2:
                    patterns: [
                      { include: "#quoted-string" }
                      { include: "#curly-string-brackets" }
                      {
                        match: "\\b([^\\s]*)\\b\\s*([^$|\n]*)?"
                        captures:
                          1: name: "string"
                          2: name: "invalid.illegal.state.title.tcl"
                      }
                    ]
              }
              {
                begin: "(?<=^|\\s)\\s*(middlewares|config|default)\\b"
                end: "(?<=})"
                beginCaptures:
                  1: name: "keyword.state.register.tcl"
                patterns: [
                  {
                    # applyEndPatternLast: 1
                    begin: "(?<=config|default)\\s*+({)"
                    end: "\\s*(})"
                    patterns: [
                      {
                        match: "\\s*([^\\s|}|{|;]*)(\\s+[^}|{|;]*)"
                        captures:
                          1: name: "variable"
                          2:
                            name: "string"
                            patterns: [
                              { include: "#constant-numeric" }
                            ]
                      }
                      {
                        include: "#curly-string-brackets"
                      }
                    ]
                  }
                  {
                    begin: "(?<=middlewares)\\s*+({)"
                    end: "\\s*(})"
                    patterns: [
                      {
                        match: "\\s*([^\\s|}|;]*)"
                        captures:
                          1: name: "meta.class.state.middleware.tcl"
                      }
                    ]
                  }
                ]
              }
              {
                begin: "(?<=^|\\s)\\s*(items)\\b"
                end: "(?<=})"
                beginCaptures:
                  1: name: "keyword.state.register.tcl"
                patterns: [
                  {
                    begin: "\\s*+({)"
                    end: "\\s*(})"
                    patterns: [
                      {
                        begin: "(?<=^|;)\\s*\\b(optional|required|key)?\\b\\s+(string|bool|number|string|ip|json|mac|enum|ni|match|include|range|percent|greater|less|dict|array|numberArray)\\b\\s+([^\\s|\\||;|}]*)"
                        end: "\\s*(?=$|;|\n)"
                        beginCaptures:
                          1:
                            name: "meta.constant"
                            patterns: [
                              {
                                match: "(key)"
                                name: "markup.bold"
                              }
                            ]
                          2: name: "support.type"
                          3: name: "variable"
                        patterns: [
                          {
                            begin: "\\s*+(\\|)"
                            end: "(?=$|;|\n)"
                            beginCaptures:
                              1: name: "support.type"
                            name: "string"
                            patterns: [
                              { include: "#constant-numeric" }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  "tcl-state-subscribe":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=subscribe)\\s+([^\\s]*)"
        end: "\\s*"
        captures:
          1: name: "meta.class.state.name.tcl"
        patterns: [
          { include: "#square-brackets" }

          {
            begin: "(?<!})\\s*({)"
            end: "\\s*(})"
            beginCaptures:
              1: name: "meta.brace.state.subscribe.params.open.tcl"
            endCaptures:
              1: name: "meta.brace.state.subscribe.params.close.tcl"
            patterns: [
              { include: "#tcl-state-common-options" }
              { include: "#variable-non-substituting" }
              { include: "#tcl-state-id" }
              {
                begin: "(?<=^|\\s|;)\\s*(conditions)\\b"
                end: "(?<=})"
                beginCaptures:
                  1: name: "keyword.state.register.tcl"
                patterns: [
                  { include: "#tcl-state-conditions" }
                ]
              }
            ]
          }
          { include: "#brackets" }
        ]
      }
    ]
  "tcl-state-common-options":
    patterns: [
      {
        match: "(?<=^|;)\\s*(config)"
        name: "keyword.control.tcl"
      }
      {
        # applyEndPatternLast: 1
        begin: "(?<=config|default)\\s*+({)"
        end: "\\s*(})"
        patterns: [
          {
            match: "\\s*([^\\s|}|{|;]*)(\\s+[^}|{|;]*)"
            captures:
              1: name: "variable"
              2:
                name: "string"
                patterns: [
                  { include: "#constant-numeric" }
                ]
          }
          {
            include: "#curly-string-brackets"
          }
        ]
      }
    ]
  "tcl-state-id":
    patterns: [
      {
        match: "(?<=^|\\s)\\s*(id)\\b(\\s+[^$|\n|;]*)"
        captures:
          1: name: "markup.bold.keyword.state.register.tcl"
          2:
            patterns: [
              { include: "#quoted-string" }
              { include: "#curly-string-brackets" }
              {
                match: "\\b([^\\s]*)\\b\\s*([^$|\n]*)?"
                captures:
                  1: name: "string"
                  2: name: "invalid.illegal.state.title.tcl"
              }
            ]
      }
    ]
  "tcl-state-conditions":
    patterns: [
      { include: "#variable-non-substituting" }
      {
        begin: "\\s*+({)"
        end: "\\s*(})"
        patterns: [
          { include: "#tcl-state-conditions" }
          { include: "#constant-numeric" }
          {
            match: "(?<=\\s|{|^)(\\*)\\s"
            name: "meta.class"
          }
          {
            match: "(?<={|^|;)\\s*([^\\s|}|\\*|;]*)\\s+"
            captures:
              1: name: "variable"
          }
          {
            match: "\\b(set|modified|change(?:d|s)|created|removed|deleted|existed|defined|exists|created|added)\\b\\s*(?=$|}|;)"
            name: "entity.function.name"
          }
          {
            match: "([^\\s]*)\\s*(?=$)"
            name: "meta.class"
          }
          {
            match: "\\b(is|becomes|was|not|reverse)\\b(?!\\s*\\|)"
            name: "punctuation.italic.entity.name.function"
          }
          {
            match: "(?<=\\s)(\\b(?:rises above|include|ne|not equal|eq|equal|greater equal|ge|greather than|ge|less equal|le|falls below|divisible by|is in|in|not in|ni|match|regexp|notInclude|startsWith|starts with|endsWith|ends with|command|isType|eval)\\b|(?:\\>|=|==|<=|>=|>_|_<|%))(?=\\s*\\|)"
            name: "support.type"
          }
          {
            begin: "\\s*+(\\|)"
            end: "(?=$|;|\n|}|\\])"
            beginCaptures:
              1: name: "entity.function.name.condition.tcl"
            name: "string"
            patterns: [
              { include: "#glob-match" }
              { include: "#constant-numeric" }
              { include: "#variable-non-substituting" }
            ]
          }
        ]
      }
    ]
  "tcl-state-setter-getter":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=set|get|pull|push)\\b"
        end: "(?=$|\n|}|\\]|;|\\[|{)"
        patterns: [
          {
            applyEndPatternLast: 1
            begin: "(?<=set|get|pull|push)\\b\\s*"
            end: "\\s*"
            patterns: [
              { include: "#tcl-class-name" }
            ]
          }
          { include: "#line-escape" }
          {
            begin: "\\s*({)"
            end: "(})"
            beginCaptures:
              1: name: "entity.function.name.state.brace.open.tcl"
            endCaptures:
              1: name: "entity.function.name.state.brace.close.tcl"
            patterns: [
              {
                match: "\\s*([^\\s|}|\\]|$|\n]*)\\s+([^\\s|}]*)"
                captures:
                  1: name: "string"
                  2: name: "variable"
              }
            ]
          }
          { include: "#brackets" }
          { include: "#variable" }
          { include: "#variable-bare" }
        ]
      }
    ]
  "tcl-class-name":
    patterns: [
      { include: "#line-escape" }
      {
        match: "(::)"
        name: "support.type"
      }
      {
        match: "(?<=::|\\s|^)([^\\s|}|\\]|;|$|\n|{|\\[]*)"
        name: "meta.class"
      }
    ]
  "tcl-incr":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(incr)\\b"
        end: "\\s*(?=$|\n|}|\\]|;)"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.incr.tcl"
        patterns: [
          { include: "#line-escape" }
          { include: "#constant-numeric" }
          { include: "#variable" }
          { include: "#variable-bare-italic" }
        ]
      }
    ]
  "tcl-lassign":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(lassign)\\b"
        end: "(?=$|\n|\\]|})"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.lassign.tcl"
        patterns: [
          { include: "#line-escape" }
          { include: "#brackets" }
          { include: "#variable" }
          { include: "#variable-bare-italic" }
        ]
      }
    ]
  "tcl-entity-commands":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(info|clock|file|task|after|tailcall|rename|callback|state|package|json|exec)\\b"
        end: "(?=$|\n|}|\\]|\\[|{)"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.file.tcl"
        patterns: [
          { include: "#line-escape" }
          {
            match: "(?<=info|clock|file|task|after|tailcall|rename|callback|state|package|json|exec)(\\s+[^\\s|\\]|}|\\[|{|;|$|\n|\"]*)"
            captures:
              1:
                patterns: [
                  { include: "#namespace-name" }
                ]
          }
          { include: "#proc-call" }
        ]
      }
    ]
  "tcl-oo":
    comment: "handle tcl specific commands and evaluation"
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=^|\\[|;)\\s*(::(oo)::)?(mixin|define|(?:meta)?class|objdefine|Helpers|InfoObject|copy|object|Slot|UnknownDefinition|Obj[0-9]*)"
        end: "\\s*"
        beginCaptures:
          1: name: "entity.function.name.tcl"
          2: name: "keyword.control.oo.tcl"
          3: name: "keyword.control.oo.command"
        patterns: [
          { include: "#tcl-oo-commands" }
        ]
      }
    ]
  "tcl-oo-commands":
    patterns: [
      { include: "#tcl-oo-create" }
      { include: "#tcl-oo-define" }
    ]
  "tcl-oo-create":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=class)\\s+(create)\\s+([^\\s]*)\\s+"
        end: "\\s*"
        captures:
          1: name: "entity.function.name.oo.create.tcl"
          2:
            name: "meta.class"
            patterns: [
              {
                match: "(::)"
                name: "support.type.namespace.sep.tcl"
              }
            ]
        patterns: [
          { include: "#tcl-oo-eval-brackets" }
        ]
      }
    ]
  "tcl-oo-define":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=define)\\s+([^\\s]*)\\s+"
        end: "\\s*"
        captures:
          1:
            name: "meta.class"
            patterns: [
              {
                match: "(::)"
                name: "support.type.namespace.sep.tcl"
              }
            ]
        patterns: [
          { include: "#tcl-oo-define-constructor" }
          { include: "#tcl-oo-define-destructor" }
          { include: "#tcl-oo-define-method" }
          { include: "#tcl-oo-eval-brackets" }
        ]
      }
    ]
  "tcl-oo-define-destructor":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(destructor)\\s+"
        end: "(?<=})"
        beginCaptures:
          1: name: "keyword.control.oo.define.constructor.tcl"
        patterns: [ { include: "#brackets" } ]
      }
    ]
  "tcl-oo-define-constructor":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(constructor)\\s+"
        end: "(?<=})"
        beginCaptures:
          1: name: "keyword.control.oo.define.constructor.tcl"
        patterns: [
          { include: "#proc-arguments" }
          { include: "#brackets" }
        ]
      }
    ]
  "tcl-oo-define-method":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(method)\\s+([^\\s]*)\\s+"
        end: "(?<=})"
        beginCaptures:
          1: name: "keyword.control.oo.define.method.tcl"
          2: name: "entity.function.name.oo.method.tcl"
        patterns: [
          { include: "#proc-arguments" }
          { include: "#brackets" }
        ]
      }
    ]
  "tcl-oo-eval-brackets":
    comment: "evaluating inside of a class create or define"
    patterns: [
      {
        begin: "\\s*+(\\{)"
        end: "\\s*(\\})"
        beginCaptures:
          1: name: "meta.bracket.curly.oo.open.tcl"
        endCaptures:
          1: name: "meta.bracket.curly.oo.close.tcl"
        patterns: [
          { include: "#line-escape" }
          { include: "#tcl-oo-my" }
          { include: "#tcl-oo-constructor" }
          { include: "#tcl-oo-method" }
          { include: "#tcl-oo-variable" }
          { include: "#tcl-oo-mixin" }
          { include: "#proc-call" }
        ]
      }
    ]
  "tcl-oo-keywords":
    patterns: [
      { include: "#tcl-oo-my" }
      { include: "#tcl-oo-self" }
    ]
  "tcl-oo-method":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "\\s*(method)\\s+([^\\s]*)\\s*"
        end: "\\s*"
        beginCaptures:
          1: name: 'keyword.control.oo.method.tcl"'
          2: name: "entity.function.name.oo.method.tcl"
        patterns: [
          { include: "#proc-arguments" }
          { include: "#tcl-oo-brackets" }
        ]
      }
    ]
  "tcl-oo-my":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*+\\b(my)\\b"
        end: "\\s*(?=$|\n|;|\\]|})"
        beginCaptures:
          1: name: "keyword.control.oo.my.punctuation.italic.tcl"
        patterns: [
          {
            begin: "(?<=my)\\b\\s+\\b(variable)\\b"
            end: "(?=$|^|\n|;)"
            beginCaptures:
              1: name: "keyword.control.my.variable.oo.tcl"
            patterns: [
              {
                match: "([^\\s|\\]|}|$])"
                name: "variable"
              }
            ]
          }
          {
            match: "(?<=my)\\b\\s+([^\\s|\\]|}]*)"
            captures:
              1: name: "entity.function.name.my.method.oo.tcl"
          }
          { include: "#proc-call-args" }
        ]
      }
    ]
  "tcl-oo-self":
    patterns: [
      {
        match: "(?<=^|\\[)\\s*+(self)\\s*"
        captures:
          1: name: "keyword.control.oo.my.punctuation.italic.tcl"
      }
    ]
  "tcl-oo-variable":
    patterns: [
      {
        match: "\\s*(variable)\\b(.*)$"
        captures:
          1: name: "keyword.control.oo.variable.tcl"
          2: name: "variable.other.tcl"
      }
    ]
  "tcl-oo-variable":
    patterns: [
      {
        begin: "(?<=^|{)\\s*\\b(constructor)\\b"
        end: "(?<=})"
        captures:
          1: name: "keyword.control.oo.variable.tcl"
          2: name: "variable.other.tcl"
        patterns: [
          { include: "#proc-arguments" }
          { include: "#brackets" }
        ]
      }
    ]
  "tcl-oo-mixin":
    patterns: [
      {
        match: "\\s*\\b(mixin)\\b(?:\\s+([^\\s|\\]|}|;]*)(?!$|\n))"
        captures:
          1: name: "keyword.control.oo.mixin.tcl"
          2:
            name: "meta.class.mixin.tcl"
            patterns: [
              { include: "#line-escape" }
            ]
      }
    ]
  "classname":
    patterns: [
      {
        match: "(?<=\\s)\\s*([^\\s]*)"
        name: "meta.class"
      }
    ]
  "tcl-expression-keywords":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "\\s*+(::)?\\b(if|expr|while)\\b\\s+(?=\\{)"
        end: "\\s*"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.if.tcl"
        endCaptures:
          1: name: "keyword.control.if.end.tcl"
        patterns: [
          { include: "#if-handlers" }
        ]
      }
    ]
  "if-handlers":
    patterns: [
      { include: "#expression-brackets" }
      { include: "#if-else-if" }
      { include: "#if-else" }
      { include: "#curly-brackets" }
    ]
  "if-else-if":
    patterns: [
      {
        begin: "(?<=\\})\\s+(elseif)\\s+"
        end: "\\s*"
        beginCaptures:
          1: name: "keyword.control.elseif.tcl"
        patterns: [
          { include: "#expression-brackets" }
          { include: "#brackets" }
        ]
      }
    ]
  "if-else":
    patterns: [
      {
        begin: "(?<=\\})\\s+(else)\\s+(?=\\{)"
        end: "(?<=\\}|$)"
        beginCaptures:
          1: name: "keyword.control.else.tcl"
        patterns: [
          { include: "#brackets" }
        ]
      }
    ]
  "if-block":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=\\})\\s*(\\{)"
        end: "\\s*(\\})"
        beginCaptures:
          1:
            name: "keyword.control"
        patterns: [
          { include: "#proc-call" }
        ]
      }
    ]
  "tcl-try-catch":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "\\s*+(try)\\s+(?={)"
        end: "\\s*"
        beginCaptures:
          1: name: "keyword.control.try.tcl"
        patterns: [
          { include: "#brackets" }
          { include: "#tcl-try-on" }
          { include: "#tcl-try-finally" }
        ]
      }
    ]
  "tcl-try-on":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=})\\s+\\b(on)\\b\\s+\\b(error|return|break|continue)\\b\\s+(?={)"
        end: "(?<=})"
        beginCaptures:
          1: name: "keyword.control.try.on.tcl"
          2: name: "keyword.control.try.on.tcl"
        patterns: [
          { include: "#arguments-braced" }
          { include: "#brackets" }
        ]
      }
    ]
  "tcl-try-finally":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=})\\s+(finally)\\s+(?={)"
        end: "(?<=})"
        beginCaptures:
          1: name: "keyword.control.try.onerror.tcl"
        patterns: [
          { include: "#brackets" }
        ]

      }
    ]
  "tcl-setters":
    patterns: [
      { include: "#tcl-set" }
      { include: "#tcl-unset" }
      { include: "#tcl-append" }
    ]
  "tcl-set":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(set|variable)\\b(?:\\s*(?!$|\n))"
        end: "\\s*(?=$|\n|\\]|}|;)"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.set.tcl"
        patterns: [
          { include: "#line-escape" }
	        { include: "#variable" }
          { include: "#variable-bare" }
          { include: "#proc-call-args" }
          {
            match: "(?<!^)([^$|\n|^|}|\\[|\\]|{]*)(?=$|\n)"
            captures:
              1:
                name: "invalid.illegal.command.tcl"
          }
        ]
      }
    ]
  "tcl-append":
    patterns: [
      {
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(append|lappend)\\s+([^\\s]*)"
        end: "(?=$|^|;|}|\\])"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.set.tcl"
          3:
            name: "punctuation.variable.set.italic.tcl"
            patterns: [
              { include: "#variable" }
            ]
        patterns: [
          { include: "#proc-call-args" }
        ]
      }
    ]
  "tcl-unset":
    patterns: [
      {
        # applyEndPatternLast: 1
        contentName: "punctuation.variable.set.italic.tcl"
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(unset)"
        end: "\\s*(?=$|;|\n|}|\\])"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.unset.tcl"
        patterns: [
          { include: "#line-escape" }
          { include: "#opt" }
          { include: "#brackets" }
          {
            match: "\\s*([^\\s|}|\\]|;]*)"
            captures:
              1: name: "punctuation.variable.set.italic.tcl"
          }
        ]
      }
    ]
  "tcl-namespace":
    patterns: [
      {
        # applyEndPatternLast: 1
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(namespace)\\s+"
        end: "\\s*(?=$|\n|}|\\])"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.namespace.tcl"
        patterns: [
          { include: "#line-escape" }
          { include: "#tcl-namespace-eval" }
          { include: "#tcl-namespace-entity-commands" }
          { include: "#tcl-namespace-subcommands" }
          { include: "#proc-call-args" }
        ]
      }
    ]
  "tcl-namespace-eval":
    # applyEndPatternLast: 1
    begin: "\\s*(eval)\\s+([^\\s]*)"
    end: "(?=$|\n|}|\\])"
    beginCaptures:
      1: name: "keyword.control.name.namespace.eval.tcl"
      2:
        patterns: [
          { include: "#line-escape" }
          { include: "#namespace-name" }
        ]
    patterns: [
      { include: "#line-escape" }
      { include: "#brackets" }
    ]
  "tcl-namespace-entity-commands":
    applyEndPatternLast: 1
    begin: "\\s*(exists|delete)\\s+([^\\s|\\]|}|;]*)"
    end: "\\s*"
    beginCaptures:
      1: name: "keyword.control.name.namespace.eval.tcl"
      2:
        # name: "meta.class"
        patterns: [
          { include: "#line-escape" }
          { include: "#namespace-name" }
        ]
    patterns: [
      { include: "#line-escape" }
      { include: "#brackets" }
    ]
  "tcl-namespace-subcommands":
    # applyEndPatternLast: 1
    match: "\\b(exists|delete|ensemble|children|code|current|export|forget|import|inscope|origin|parent|path|qualifiers|tail|upvar|unknown|which)\\b"
    captures:
      1: name: "entity.function.name.namespace.subcommand.tcl"
  "namespace-name":
    begin: "(?<=^|\\[|{|;)"
    end: "(?=}|\\s|\\]|;)"
    name: "entity.function.name"
    patterns: [
      { include: "#variable" }
      {
        match: "(:)(?!:)"
        name: "string"
      }
      {
        match: "(::)"
        name: "support.type.tcl"
      }
      {
        match: "([^\\s|::|\\]|}|;]*)"
        name: "entity.function.name"
      }
    ]
  "tcl-foreach":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=^|\\[|{|;)\\s*(::)?\\b(foreach)\\s+((?!{|\\[)([^\\s]*))?"
        end: "\\s*"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.foreach.loop.tcl"
          3: name: "punctuation.variable.set.italic.tcl"
        patterns: [
          { include: "#arguments-braced" }
          { include: "#brackets" }
        ]
      }
    ]
  "tcl-catch":
    patterns: [
      {
        begin: "(?<=\\[|{|^)\\s*(::)?\\b(catch)\\b"
        end: "\\s*(?=\\]|}|$|;)"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.string.tcl"
        patterns: [
          { include: "#brackets" }
          { include: "#variable-bare" }
        ]
      }
    ]
  "tcl-info":
    patterns: [
      {
        begin: "(?<=\\[|\\{|^)\\s*(::)?\\b(info)\\b\\s+"
        end: "\\s*(?=\\]|}|$|;)"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.string.tcl"
        patterns: [
          { include: "#tcl-info-exists" }
          { include: "#tcl-info-class" }
          { include: "#tcl-info-vars" }
          { include: "#tcl-info-subcommands" }
        ]
      }
    ]
  "tcl-info-exists":
    patterns: [
      {
        match: "(exists)\\s+([^\\s|\\]|}]*)"
        captures:
          1: name: "entity.function.name.info.exists.tcl"
          2: name: "punctuation.variable.info.exists.italic.tcl"
      }
    ]
  "tcl-info-class":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "\\b(class)\\b\\s+"
        end: "\\s*"
        captures:
          1: name: "entity.function.name.info.tcl"
        patterns: [
          {
            match: "\\b(call|constructor|definition|destructor|filters|forward|instances|methods|methodtype|mixins|subclasses|superclasses|variables)\\b\\s+([^\\s]*)"
            captures:
              1: name: "keyword.control.info.class.tcl"
              2: name: "meta.class.info.tcl"
          }
        ]
      }
    ]
  "tcl-info-vars":
    patterns: [
      {
        begin: "\\b(vars)\\b\\s+"
        end: "\\s*(?=$|\n|;|\\]|})"
        beginCaptures:
          1: name: "entity.function.name.info.tcl"
        patterns: [
          { include: "#glob-match" }
          { include: "#variable-bare" }
        ]
      }
    ]
  "tcl-info-subcommands":
    patterns: [
      {
        match: "(level|frame|commands)(\\s+[^\\s|\\]|}|;|$]*)?"
        captures:
          1: name: "entity.function.name.tcl"
          2:
            patterns: [
              { include: "#constant-numeric" }
              { include: "#namespace-name" }
            ]
      }
    ]
  "tcl-string":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=\\[|\\{|^)\\s*(::)?\\b(string)\\b"
        end: "\\s*"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.string.tcl"
        patterns: [
          { include: "#tcl-string-is" }
          { include: "#tcl-string-match" }
          { include: "#tcl-string-map" }
          { include: "#tcl-string-subcommands" }
        ]
      }
    ]
  "tcl-string-is":
    patterns: [
      {
        match: "\\s*\\b(is)\\b\\s+([^\\s|}|\\]|;]*)"
        captures:
          1: name: "entity.function.name.string.is.tcl"
          2: name: "support.type"
      }
    ]
  "tcl-string-match":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "\\s*\\b(match)\\b\\s+"
        end: "\\s*"
        captures:
          1: name: "entity.function.name.string.is.tcl"
          2: name: "string"
        patterns: [
          { include: "#glob-match" }
        ]
      }
    ]
  "tcl-string-map":
    patterns: [
      {
        # applyEndPatternLast: 1
        begin: "\\s*\\b(map)\\b"
        end: "\\s*(?=$|\n|\\]|}|{|\\[)"
        captures:
          1: name: "entity.function.name.string.map.tcl"
        patterns: [
          { include: "#square-brackets" }
          { include: "#variable" }
          {
            begin: "\\s*({)"
            end: "\\s*(})"
            patterns: [
              { include: "#square-brackets" }
              { include: "#quoted-string" }
              { include: "#curly-string-brackets" }
            ]
          }
        ]
      }
    ]
  "tcl-string-subcommands":
    patterns: [
      {
        match: "(?<=string)\\b\\s+(match|toupper|tolower|bytelength|compare|cat|first|index|is|last|length|map|range|repeat|replace|reverse|totitle|trim|trimleft|trimright|wordend|wordstart|equal)\\s+"
        # name: "entity.function.name.string.subcommands.tcl"
        name: "entity.function.name.string.subcommands.tcl"
      }
    ]
  "tcl-dict":
    patterns: [
      {
        applyEndPatternLast: 1
        begin: "(?<=\\[|{|^)\\s*(::)?\\b(dict)\\b\\s+"
        end: "\\s*"
        beginCaptures:
          1: name: "support.type"
          2: name: "keyword.control.dict.tcl"
        patterns: [
          { include: "#tcl-dict-keywords" }
          { include: "#tcl-dict-subcommands" }
        ]
      }
    ]
  "tcl-dict-keywords":
    patterns: [
      { include: "#tcl-dict-blocks" }
      { include: "#tcl-dict-setters" }
    ]
  "tcl-dict-blocks":
    applyEndPatternLast: 1
    begin: "(for|update|with)\\s+((?!{|\\[)([^\\s]*))?"
    end: "(?<=})"
    beginCaptures:
      1: name: "entity.function.name.dict.for.tcl"
      2:
        name: "punctuation.variable.set.italic.tcl"
        patterns: [
          { include: "#variable" }
        ]
    patterns: [
      { include: "#variable" }
      { include: "#arguments-braced" }
      { include: "#brackets" }
    ]
  "tcl-dict-setters":
    patterns: [
      {
        begin: "(set|pull|unset|lappend)(\\s+(?!{|\\[)[^\\s]*)?"
        end: "(?=$|^|\\]|})"
        beginCaptures:
          1: name: "entity.function.name.dict.subcommand.tcl"
          2:
            patterns: [
              { include: "#variable-bare" }
              { include: "#variable" }
            ]
        patterns: [
          { include: "#proc-call-args" }
        ]
      }
    ]
  "tcl-dict-subcommands":
    patterns: [
      {
        match: "\\b(append|create|exists|filter|get|get\\?|incr|info|keys|lappend|map|merge|remove|replace|set|size|unset|update|values|with|pull|push|pullFrom)\\b"
        name: "entity.function.name.dict.subcommand.tcl"
      }
    ]
  "proc-arguments":
    patterns: [
      { include: "#proc-args-braced" }
      { include: "#proc-args-singular" }
    ]
  "proc-args-singular":
    patterns: [
      {
        match: "(?!{|\\[|\\s|}|\\]|$)([^\\s]*)(?=\\s)"
        captures:
          1: name: "punctuation.definition.variable.tcl"
      }
    ]
  "proc-args-braced": {
    begin: "(?!\\s)(?={)({)\\s*"
    end: "\\s*(})"
    beginCaptures:
      1: name: "meta.brace.curly.proc.args.open.tcl"
    endCaptures:
      1: name: "meta.brace.curly.proc.args.close.tcl"
    patterns: [
      { include: "#proc-arguments-nested" }
      { include: "#variable-bare" }
    ]
  }
  "proc-arguments-nested":
    patterns: [
      {
        begin: "\\s*+({)\\s*"
        end: "\\s*(})"
        beginCaptures:
          1: name: "entity.function.name"
        endCaptures:
          1: name: "entity.function.name"
        patterns: [
          { include: "#quoted-string" }
          { include: "#curly-string-brackets" }
          {
            match: "\\s*([^\\s|{|}]*)\\s*([^\\s|{|}]*)(?=\\s*?})"
            name: "variable"
            captures:
              1: name: "variable"
              2:
                name: "string"
                patterns: [
                  { include: "#constant-numeric" }
                ]
          }
          {
            match: "\\s*([^\\s|{|}]*)"
            name: "string.quoted"
          }

        ]
      }
    ]
  "arguments-braced":
    patterns: [
      {
        begin: "({)\\s*"
        end: "(})"
        patterns: [
          {
            match: "([^\\s|{|}]*)\\s*"
            name: "variable"
          }
        ]
      }
    ]
  "double-dash":
    match: "\\s(--)\\s"
    captures:
      1: name: "keyword.control.tcl"
  "quoted-string":
    begin: "\\s*+((\"))"
    end: "\\s*(\")"
    # contentName: "string.quoted.double.tcl"
    beginCaptures:
      1: name: "string.quoted.double.open.tcl"
    endCaptures:
      1: name: "string.quoted.double.close.tcl"
    patterns: [
      { include: "#string-content" }
    ]
  "string-content":
    patterns: [
      {
        name: "constant.character.escape.newline.tcl"
        match: "\\\\\n"
      }
      {
        name: "constant.character.escape.newline.tcl"
        match: "(?<=\\s)\\\\"
      }
      {
        name: "constant.character.escape"
        match: "\\\\['\"\\\\nrtbfv0`]"
      }
      {
        name: "constant.character.escape"
        match: "\\\\u(({[0-9a-fA-F]+\\})|[0-9a-fA-F]{4})"
      }
      {
        name: "constant.character.escape"
        match: "\\\\x[0-9a-fA-F]{2}"
      }
      { include: "#variable" }
      { include: "#bare-string" }
    ]
  "bare-string":
    patterns: [
      {
        match: "(\\s*[^\\s|}|\\]|;|-|{|\\[|\"|:])"
        captures:
          1:
            name: "string"
            patterns: [
              { include: "#variable" }
            ]
      }
      {
        match: "(?<!:)(:)(?!:)|(?<=::)(:)(?!:)"
        name: "string"
      }
      {
        match: "\\s*(::)(?!:(?<!:))"
        name: "support.type"
      }
    ]

  "comment-blocks":
    patterns: [
      {
        contentName: "comment.line.number-sign.tcl"
        begin: "(?<=^|;|{)\\s*((#))"
        end: "(?=$|\n)"
        captures:
          1: name: "comment.line.number-sign.tcl"
          2: name: "punctuation.definition.comment.tcl"
      }
      {
        contentName: "comment.block.tcl"
        begin: "(?<=^|;|\\{)\\s*((?:\\%\\s+\\{)|(?:\\bif\\s+{?0}?\\s+{))"
        end: "\\s*(\\})"
        beginCaptures:
          1: name: "comment.block.multi.start.tcl"
          2: name: "punctuation.definition.comment.tcl"
        endCaptures:
          1: name: "comment.block.multi.end.tcl"
        patterns: [
          { include: "#annotate" }
          { include: "#opt" }
          { include: "#variable" }
        ]
      }
    ]
  "annotate":
    patterns: [
      { include: "#annotate-control-block" }
      { include: "#annotate-title" }
      { include: "#annotate-header" }
      { include: "#annotate-highlight" }
      { include: "#annotate-type" }
      { include: "#annotate-list" }
    ]
  "annotate-title":
    patterns: [
      {
        comment: "adding @ in a multi-line will make the line emphasized"
        contentName: "meta.class.comment.annotate.tcl"
        begin: "\\s*+(@)"
        end: "(?={)|(@|}|$|\n)|\\|"
        beginCaptures:
          1: name: "support.type.annotate.tcl"
        endCaptures:
          1: name: "support.type.annotate.tcl"
      }
    ]
  "annotate-control-block":
    patterns: [
      {
        comment: "bracketed within a comment"
        contentName: "keyword.operator"
        begin: "^\\s*+(?={)"
        end: "(?<=})"
        patterns: [
          { include: "#brackets" }
        ]
      }
    ]
  "annotate-type":
    patterns: [
      {
        comment: "adding @ in a multi-line will make the line emphasized"
        contentName: "entity.function.name.comment.annotate.tcl"
        begin: "\\s*+({)"
        end: "\\s*(})"
        beginCaptures:
          1: name: "meta.constant.comment.annotate.tcl"
        endCaptures:
          1: name: "meta.constant.comment.annotate.tcl"
        patterns: [
          {
            match: "(\\|)"
            name: "meta.constant.comment.annotate.tcl"
          }
        ]
      }
    ]
  "annotate-highlight":
    patterns: [
      {
        comment: "adding | in a multi-line will make the line highlighted (string)"
        match: "(?<=\\|)\\s*([^\\||}|{|$]*)"
        captures:
          1:
            name: "string.quote.annotate.comment.tcl"
            patterns: [
             {
               match: "\\b(http://([^\\s]*))"
               name: "entity.function.name.markup.underline"
             }
           ]
      }
    ]
  "annotate-header":
    patterns: [
      {
        comment: "adding > in a multi-line will make the line emphasized"
        match: "\\s*+(>)\\s+([^}|^|$|\\||>|{|}]*)"
        captures:
          1: name: "entity.function.name.annotate.tcl"
          2: name: "meta.constant.annotate.header.tcl"
      }
    ]
  "annotate-list":
    patterns: [
      {
        match: "^\\s*([0-9]\\.)\\s+"
        name: "meta.class"
      }
    ]
  "opt":
    comment: "Handle options sent to commands at various points (cmd -name1 value -name2 value)"
    match: "\\s*+(?<=\\s|^)((-)(?!-|\\s)[^\\s|$|\n|\\[|\\]]*)"
    captures:
      1: name: "meta.constant.opt.tcl"
      2: name: "entity.function.name.opt.start.tcl"
  "line-escape": {
    begin: "\\s*+(\\\\\n)$"
    end: "(?<=^)\\s*"
    beginCaptures:
      1: name: "constant.character.escape.newline.tcl"
  }
  "glob-match":
    patterns: [
      {
        begin: "(?<!\\\\)(\")"
        end: "(?<!\\\\)(\")"
        beginCaptures:
          1: name: "string.double.quoted.glob.match.open.tcl"
        endCaptures:
          1: name: "string.double.quoted.glob.match.close.tcl"
        patterns: [
          { include: "#glob-match" }
        ]
      }
      {
        match: "(\\\\)"
        name: "constant.character.escape.tcl"
      }
      {
        match: "\\s*(?<!\\\\)(\\*|\\?)"
        name: "meta.class"
      }
      {
        begin: "(?<!\\\\)(\\[)"
        end: "(?<!\\\\)(\\])"
        contentName: "support.type"
        beginCaptures:
          1: name: "meta.class"
        endCaptures:
          1: name: "meta.class"
      }
      { include: "#bare-string" }
    ]
  "spread-variable-only":
    comment: "Only allow a variable if it is spread using {*}"
    patterns: [
      {
        match: "(?<=^|\\[)\\s*(?<!\\{\\*\\})(\\$)(([a-zA-Z0-9_]|::)+(\\([^\\)]+\\))?|\\{[^\\}]*\\})"
        captures:
          1: name: "invalid.illegal.nospread.tcl"
          2: name: "invalid.illegal.nospread.tcl"
      }
      {
        include: "#variable"
      }
    ]
  "spread-variable":
    patterns: [
      {
        match: "\\s*+(\\{(\\*)\\}?)(?=\\$)"
        captures:
          1: name: "entity.function.name.tcl.markup.italic"
          2: name: "support.type"
      }
    ]
  "variable-bare-italic":
    patterns: [
      {
        begin: "(?!\\s|$|^|\\$)(?<=\\s|{|\\[|\\*)"
        end: "\\s*(?=\\s|}|\\]|;|$|\\*)"
        patterns: [
          {
            begin: "\\s*+(\\()"
            end: "\\s*(\\))"
            contentName: "punctuation.italic.variable"
            beginCaptures:
              1: name: "support.type"
            endCaptures:
              1: name: "support.type"
          }
          {
            match: "(:)(?!:)"
            name: "string"
          }
          {
            match: "(::)"
            name: "support.type"
          }
          {
            match: "(?!\\s|$|^)([^\\s|\\*|::|}|\\]|\\)|\\(|\"|;|^|$]*)"
            name: "punctuation.italic.variable"
          }
          {
            match: "(?<=\\*)(?!\\s|$|^)([^\\s|\\*|::|}|\\]|\\)|\\(|\"|;|^|$]*)"
            name: "punctuation.italic.variable"
          }

        ]
      }
    ]
  "variable-bare":
    patterns: [
      {
        begin: "(?!\\s|$|^)(?<=\\s|{|\\[|\\*)"
        end: "(?=\\s|}|\\]|;|$|\\*)"
        patterns: [
          {
            begin: "\\s*+(\\()"
            end: "\\s*(\\))"
            contentName: "punctuation.italic.variable"
            beginCaptures:
              1: name: "support.type"
            endCaptures:
              1: name: "support.type"
          }
          {
            match: "(:)(?!:)"
            name: "string"
          }
          {
            match: "(::)"
            name: "support.type"
          }
          {
            match: "(?!\\s|$|^)([^\\s|\\*|::|}|\\]|\\)|\\(|\"|;|^|$]*)"
            name: "variable"
          }
          {
            match: "(?<=\\*)(?!\\s|$|^)([^\\s|\\*|::|}|\\]|\\)|\\(|\"|,|;|^|$]*)"
            name: "variable"
          }

        ]
      }
    ]
  "variable-braced":
    patterns: [
      {
        begin: "(?={)({)"
        end: "(}|\\s)"
        patterns: [
          { include: "#variable-bare" }
        ]
      }
    ]
  "variable":
    patterns: [
      { include: "#spread-variable" }
      {
        match: "\\s*+(?<!(?<!\\\\)\\\\)(\\$)(?:({)([^}|\\s|\\]|\"|\\)|\\(|\\$]*)(\\(.*\\))?(})|(?=[A-Za-z0-9_:])([^\\s|}|\\]|\"|\\)|;|\\(|\\$|,]*))(\\(.*\\))?"
        captures:
          1: name: "support.type.variable.indicator.tcl"
          2: name: "entity.function.name.variable.brace.open.tcl"
          3:
            patterns: [
              {
                match: "(::)"
                name: "support.type"
              }
              {
                match: "([^\\s|::|\"|}|{])"
                name: "variable.name"
              }
            ]
          4:
            patterns: [
              {
                begin: "(\\()"
                end: "(\\))"
                contentName: "punctuation.italic.variable"
                beginCaptures:
                  1: name: "support.type"
                endCaptures:
                  1: name: "support.type"
              }
            ]
          5: name: "entity.function.name.variable.brace.close.tcl"
          6:
            patterns: [
              {
                match: "(::)"
                name: "support.type"
              }
              {
                match: "([^\\s|::|\"|}|{])"
                name: "variable.name"
              }
            ]
          7:
            patterns: [
              {
                begin: "(\\()"
                end: "(\\))"
                contentName: "punctuation.italic.variable"
                beginCaptures:
                  1: name: "entity.function.name"
                endCaptures:
                  1: name: "entity.function.name"
              }
            ]

      }
    ]
  "variable-non-substituting":
    patterns: [
      { include: "#spread-variable" }
      {
        match: "\\s*+(?<!(?<!\\\\)\\\\)(\\$)(?:({)([^\\s|}|\\]|\"]*)(})|(?=[A-Za-z0-9_:])([^\\s|}|\\]|\"|\\)|\\(]*))"
        captures:
          1: name: "support.type.variable.indicator.tcl"
          2: name: "entity.function.name.variable.brace.open.tcl"
          3:
            patterns: [
              {
                match: "(::)"
                name: "support.type"
              }
              {
                match: "([^\\s|::|\"]*)"
                name: "meta.constant"
              }
            ]
          4: name: "entity.function.name.variable.brace.close.tcl"
          5:
            patterns: [
              {
                match: "(::)"
                name: "support.type"
              }
              {
                match: "([^\\s|::|\"])"
                name: "meta.constant"
              }
            ]

      }
    ]
